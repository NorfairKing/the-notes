module Groups.Main where

import           Notes                           hiding (inverse)

import           Functions.Basics.Macro
import           Functions.BinaryOperation.Terms
import           Logic.FirstOrderLogic.Macro
import           NumberTheory.Macro
import           Sets.Basics.Terms

import           Groups.Macro
import           Groups.Terms

groups :: Note
groups = chapter "Groups" $ do
    magmaDefinition
    semigroupDefinition
    monoidDefinition
    groupDefinition

    inverseUniqueTheorem
    inverseOfAppliedOperationTheorem

    subgroupDefinition
    subgroupSameIdentity
    trivialSubgroupsDT

    generatedSetDefinition
    generatedSetIsGroup
    cyclicGroupDefinition

    groupOrderDefinition
    orderDefinition
    elementOrderDividesGroupOrder

magmaDefinition :: Note
magmaDefinition = de $ do
    lab magmaDefinitionLabel
    s ["A", magma', m mgm_, "is a", set <> ", equipped with a", binaryOperation]
    ma $ fun2 (pars $ "" · "") mgms_ mgms_ mgms_

semigroupDefinition :: Note
semigroupDefinition = de $ do
    lab semigroupDefinitionLabel
    s ["A", magma, m sgrp_, "is called a", semigroup', "if its operation", m $ "" ˙ "", "is", associative_]

monoidDefinition :: Note
monoidDefinition = de $ do
    lab monoidDefinitionLabel
    lab identityDefinitionLabel
    lab neutralElementDefinitionLabel
    s ["A", semigroup, m mnd_, "is called a", monoid', "if it has an", identity_, m mid_]

groupDefinition :: Note
groupDefinition = de $ do
    lab groupDefinitionLabel
    lab inverseDefinitionLabel
    lab neutralElementDefinitionLabel
    s ["A", monoid, m grp_, "is called a", group', "if every", element, "has an", inverse', "with respect to the", identity, m gid_]
    let a = "a"
        ai = ginv a
    ma $ fa (a ∈ grps_) $ te (ai ∈ grps_) $ a ** ai =: gid_ =: ai ** a
    s ["In a", group, "the", identity, "is sometimes called the", neutralElement']

inverseUniqueTheorem :: Note
inverseUniqueTheorem = thm $ do
    lab inverseUniqueTheoremLabel
    s ["Let", m grp_, "be a", group]
    s ["For every", element, "of", m grps_, "there exists exactly one", inverse, element]

    proof $ do
        let x = "x"
            y = "y"
            z = "z"
        s ["Suppose that an", element, m x, "has two", inverses, m y, and, m z, "in a", group, m grp_, "with", identity, m gid_]
        aligneqs y
            [ y ** gid_
            , y ** pars (x ** z)
            , pars (y ** x) ** z
            , gid_ ** z
            , z
            ]

inverseOfAppliedOperationTheorem :: Note
inverseOfAppliedOperationTheorem = thm $ do
    lab inverseOfAppliedOperationTheoremLabel
    s ["Let", m grp_, "be a", group]
    let x = "x"
        y = "y"
    ma $ fa (cs [x, y] ∈ grps_) $ ginv (pars $ x ** y) =: ginv y ** ginv x

    proof $ do
        s ["Let", m x, and, m y, "be", elements, "of", m grps_, and, "let", m gid_, "be the", identity, "of the", group, m gid_]
        aligneqs (ginv $ pars $ x ** y)
            [ (ginv $ pars $ x ** y) ** gid_
            , (ginv $ pars $ x ** y) ** (pars $ x ** ginv x)
            , (ginv $ pars $ x ** y) ** (pars $ (pars $ x ** gid_) ** ginv x)
            , (ginv $ pars $ x ** y) ** (pars $ (pars $ x ** (pars $ y ** ginv y)) ** ginv x)
            , (ginv $ pars $ x ** y) ** (pars $ (pars $ pars (x ** y) ** ginv y) ** ginv x)
            , pars ((ginv $ pars $ x ** y) ** (pars $ pars (x ** y) ** ginv y)) ** ginv x
            , pars (pars ((ginv $ pars $ x ** y) ** (pars (x ** y))) ** ginv y) ** ginv x
            , pars (gid_ ** ginv y) ** ginv x
            , ginv y ** ginv x
            ]


subgroupDefinition :: Note
subgroupDefinition = de $ do
    lab subgroupDefinitionLabel
    let h = "H"
    s ["Let", m grp_, "be a", group, "and let", m h, "be a subset of", m grps_]
    s ["If", m $ grp h grpop_, "is a", group, "in and of itself, it is called a", subgroup', "of", m grp_]

subgroupSameIdentity :: Note
subgroupSameIdentity = thm $ do
    lab subgroupSameIdentityTheoremLabel
    let h = "H"
        sg = grp h grpop_
    s ["Let", m grp_, "be a", group, "and let", m sg, "be a", subgroup, "of", m grp_]
    s [m grp_, and, m sg, "have the same", neutralElement]

    toprove

trivialSubgroupsDT :: Note
trivialSubgroupsDT = thm $ do
    s ["Let", m grp_, "be a", group]
    s [m grp_, and, m $ grp (setof gid_) grpop_, "are subgroups of", m grp_]
    s ["They are called the", trivialSubgroups', "of", m grp_]

    toprove

generatedSetDefinition :: Note
generatedSetDefinition = de $ do
    let x = "x"
    s ["Let", m grp_, "be a", group, "and let", m x, "be an", element, "of", grps_]
    s [the, set, m $ genby x, "generated by", m x, "is defined as follows"]
    let s = "s"
    ma $ genby x === setcmpr (x ^ s) (s ∈ ints)

generatedSetIsGroup :: Note
generatedSetIsGroup = thm $ do
    lab generatedSetIsGroupTheoremLabel
    let x = "x"
    s ["Let", m grp_, "be a", group, "and let", m x, "be an", element, "of", grps_]
    s [m $ grp (genby x) grpop_, "is a", group]
    s ["It is called the", group, "generated by", m x]

    toprove

cyclicGroupDefinition :: Note
cyclicGroupDefinition = de $ do
    lab cyclicDefinitionLabel
    lab generatorDefinitionLabel
    s ["A", cyclic', group, "is a group that is generated by a single element"]
    s ["That element is then called the", generator']

groupOrderDefinition :: Note
groupOrderDefinition = de $ do
    s [the, order, "of a", group, m $ grp_, "is defined as the size", m $ setsize grps_, "of", m grps_]

orderDefinition :: Note
orderDefinition = de $ do
    lab orderDefinitionLabel
    s ["Let", m grp_, "be a", group, "with", neutralElement, m gid_]
    let x = "x"
        o = "o"
    s [the, order', "of an element", m x, "in", m grps_, "is defined as the smallest integer", m o, "that satisfies the following equation"]
    ma $ x ^ o =: gid_

elementOrderDividesGroupOrder :: Note
elementOrderDividesGroupOrder = thm $ do
    lab elementOrderDividesGroupOrderTheoremLabel
    todo "write out"
    s [the, order, "of every", element, "divides the", group, order]
    todo "What was the name of this theorem"

